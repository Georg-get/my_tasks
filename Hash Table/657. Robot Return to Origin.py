### Условие задачи:
# Есть робот, стартующий из (0, 0)исходной позиции на 2D-плоскости.
# Учитывая последовательность его движений, определите, окажется ли этот робот в точке(0, 0) после того, как завершит свои движения.
# Вам дана строка moves, которая представляет последовательность движений робота,
# где moves[i]представляет его ход. Допустимые ходы: (вправо), (влево), (вверх) и (вниз).ith'R''L''U''D'
# Возврат true, если робот возвращается в исходное положение после завершения всех своих движений или falseв противном случае .
# Примечание . То, как «повернулся» робот, не имеет значения. 'R'всегда заставит робота двигаться вправо один раз, 'L'всегда заставит его двигаться влево и т. д.
# Кроме того, предположим, что величина движения робота одинакова для каждого движения.

### Краткое условие:
# Возврат true, если робот возвращается в исходное положение после завершения всех своих движений
# или false в противном случае.

# Алгоритм решение задачи:
# 0) Создаем словарь dict с буквами как ключи а значение у них 0.
# 1) Проходимся циклом по строке moves,
# 1.1) Если ключ i есть в словаре dict, то увеличь значение ключа i на 1.
# 2) Если значение ключа 'U' и 'D' равны и значение ключа 'L' и 'R' равны, то верни True.
# 3) Если значение  ключа 'U' и 'D' НЕ РАВНЫ и значение ключа 'L' и 'R' НЕ РАВНЫ, то верни False.

# Сложность:
# 1) Время O(n)
# 2) Память O(1)

moves = "UD"

def judgeCircle(moves):
    dict = {'U': 0, 'D': 0, 'L': 0, 'R': 0}

    for i in moves:
        if i in dict:
            dict[i] += 1
    # {'U': 1, 'D': 1, 'L': 0, 'R': 0}
    if dict['U'] == dict['D'] and dict['L'] == dict['R']:
        return True
    else:
        return False

judgeCircle(moves)

assert judgeCircle(moves="UD") == True
assert judgeCircle(moves="LL") == False