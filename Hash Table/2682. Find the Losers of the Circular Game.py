### Условие задачи:
# Есть nд рузья, которые играют в игру. Друзья сидят в кругу и пронумерованы от 1до nпо часовой стрелке . Более формально,
# перемещение по часовой стрелке от друга приведет вас к другу на , а движение по часовой стрелке от друга приведет вас к другу.ith(i+1)th1 <= i < nnth1st
# Правила игры следующие:
# 1 st друг получает мяч.
# После этого друг передает его другу, находящемуся от него в нескольких шагах по часовой стрелке .1stk
# После этого друг, получивший мяч, должен передать его другу, находящемуся 2 * kот него в нескольких шагах по часовой стрелке .
# После этого друг, получивший мяч, должен передать его другу, находящемуся 3 * kот него в нескольких шагах по часовой стрелке , и так далее, и тому подобное.
# Другими словами, на ходу друг, держащий мяч, должен передать его другу, находящемуся в нескольких шагах от него по часовой стрелке.ithi * k
# Игра заканчивается, когда кто-то из друзей получает мяч во второй раз.
# Проигравшими в игре считаются друзья, не получившие мяча за всю игру.
# Учитывая количество друзей n и целое число k, верните массив ответ, который содержит проигравших в игре в порядке возрастания .

# Example 1:
# Input: n = 5, k = 2
# Output: [4,5]
# Explanation: The game goes as follows:
# 1) Start at 1st friend and pass the ball to the friend who is 2 steps away from them - 3rd friend.
# 2) 3rd friend passes the ball to the friend who is 4 steps away from them - 2nd friend.
# 3) 2nd friend passes the ball to the friend who is 6 steps away from them  - 3rd friend.
# 4) The game ends as 3rd friend receives the ball for the second time.

# Example 2:
# Input: n = 4, k = 4
# Output: [2,3,4]
# Explanation: The game goes as follows:
# 1) Start at the 1st friend and pass the ball to the friend who is 4 steps away from them - 1st friend.
# 2) The game ends as 1st friend receives the ball for the second time.

### Добавить в список !

### Краткое условие:
# Верните массив с номерами друзья (проигравшими в игре), которые ни разу не получили мяч. В порядке возрастания.

# Краткое объяснение решение задачи:
# Создается множество dictSet, содержащее номера игроков от 1 до n.
# Внешний цикл проходит n раз.
#    - На каждой итерации вычисляется индекс игрока, который выбывает, с помощью формулы (count + (k * j)) % n.
#    - Если вычисленный игрок уже выбывает (не находится в dictSet), цикл прерывается.
#    - В противном случае, игрок удаляется из множества.
# Возвращается список оставшихся игроков (проигравших).

# Полное объяснение решение задачи:
# 0) Создаем пустое множество dictSet и переменную count со значение 0.
# 1) Проходимся циклом по диапозону от 1 до n+1, добавляем индекс i в множество dictSet.
# 2) Проходимся циклом по диапозону от 0 до n,
# 2.1) count равно (count + (k умноженое на j) деленое на n)
# 2.2) Если ключ count+1 НЕТ в словаре dictSet, то выйди из цикла.
# 2.3) Иначе, удали число которое равно count + 1 из множество dictSet.
# 3) Верни массив из множество dictSet.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

### Сложная задача !!!

n = 5
k = 2

def circularGameLosers(n, k):
    dictSet = set()
    count = 0

    for i in range(1, n + 1):  # от 1 до 5+1         ### тут условие для 1 юнитеста
        dictSet.add(i)
    # {1, 2, 3, 4, 5}

    for j in range(n):  ### от 0 до 5                ### тут условие для 3 и 4 юнитеста

        count = (count + (k * j)) % n

        if count + 1 not in dictSet:  # 1) {1, 2, 3, 4, 5}
            break  # 2) {2, 3, 4, 5}
        else:  # 3) {2, 4, 5}
            dictSet.remove(count + 1)  # 4) {4, 5}
    # {4, 5}
    return list(dictSet)  # [4,5]

circularGameLosers(n, k)

assert circularGameLosers(n=5, k=2) == [4, 5]
assert circularGameLosers(n=4, k=4) == [2, 3, 4]
assert circularGameLosers(n=16, k=1) == []  ### этот тест ломает код если не будет range(n)
assert circularGameLosers(n=32, k=1) == []  ### этот тест ломает код если не будет range(n)
# Доп юнитесты для проверки некоторых условий:
assert circularGameLosers(n=1, k=1) == []  # Минимальные значения

### Старое решение через хэш таблицу !!! ###
# Полное объяснение решение задачи:
# 0) Создаем пустой массив result и пустой словарь dict, и переменную i равное 1 и переменную step равное 1.
# 1) Проходимся циклом по диапазону от 1 до n+1, добавляем ключ x со значением 0 в словарь dict.
# 2) Значение ключа 1 равно 1.
# 3) Проходимся циклом ваид пока ключ step не будет равен 2,
# 3.1) step равен step + (i умноженае на k) деленое на n.
# 3.2) Если step равно 0, то step равно n.
# 3.3) Значение ключ step = значение ключа step +1
# 3.4) Увеличиваем переменную i на 1.
# 4) Проходимся циклом по словарю dict,
# 4.1) Если значение ключа k из словаря dict равно 0, то добавь ключ k в массив result.
# 5) Верни result.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)
#
#
# n = 5
# k = 2
#
# def circularGameLosers(n, k):
#     result = []
#     dict = {}
#     i = 1
#     step = 1
#
#     for x in range(1, n + 1):
#         dict[x] = 0
#     dict[1] = 1
#     # {1: 1, 2: 0, 3: 0, 4: 0, 5: 0}
#     while dict[step] != 2:
#         step = (step + (i * k)) % n
#         if step == 0:
#             step = n
#         dict[step] = dict[step] + 1
#         i += 1
#     # {1: 1, 2: 1, 3: 2, 4: 0, 5: 0}
#     for k in dict:
#         if dict[k] == 0:
#             result.append(k)
#     # [4, 5]
#     return result
#
# circularGameLosers(n, k)

### Старое решение через хэш таблицу !!! ###
# Полное объяснение решение задачи:
# 0) Создаем переменные: start = 0 и p = 1, и словарь dictSet и пустой массив result.
# 1) Проходимся циклом ваилд пока start не будет в словаре dictSet,
# 1.1) Добавляем start в словарь dictSet.
# 1.2) Увеличиваем start на p * k, и делем start на n, увеличиваем p на 1.
# 2) Проходимся циклом по диапазону от 0 до n,
# 2.1) Если ключа i нету в словаре dictSet, то добавляем i+1 в массив result.
# 3) Вернуть result.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

# n = 5
# k = 2
#
#
# def circularGameLosers(n, k):
#     start = 0
#     p = 1
#     dictSet = set()
#     result = []
#
#     while start not in dictSet:
#         dictSet.add(start)
#         start += p * k
#         start %= n
#         p += 1
#     # {0, 1, 2}
#     for i in range(n):
#         if i not in dictSet:
#             result.append(i + 1)
#     # [4, 5]
#     return result
#
#
# circularGameLosers(n, k)
