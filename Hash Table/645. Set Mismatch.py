### Условие задачи:
# У вас есть набор целых чисел s, который изначально содержит все числа от 1 до n.
# К сожалению, из-за какой-то ошибки одно из чисел в s наборе дублировалось на другое число в наборе,
# что привело к повторению одного числа и потере другого числа.
# Вам предоставляется целочисленный массив nums, представляющий состояние данных этого набора после ошибки.
# Найдите число, которое встречается дважды , и число, которое отсутствует, и верните их в виде массива.

# Example 1:
# Input: nums = [1,2,2,4]
# Output: [2,3]

# Example 2:
# Input: nums = [1,1]
# Output: [1,2]

### Краткое условие:
# Необходимо найти дублирующееся число и отсутствующее число, и вернуть их в виде массива.

# Краткое объяснение решение задачи:
# Используется словарь для отслеживания встреченных чисел.
# При нахождении дубликата он сохраняется.
# Вычисляется сумма от 1 до n и вычитается сумма элементов массива (с учетом дубликата), чтобы найти отсутствующее число.

# Полное объяснение решение задачи:
# 0) Создаем пересенные result равной 0 и lenNums которой равна длине массива nums, и пустой словарь dict.
# 1) Проходимся циклом по массиву nums,
# 1.1) Если ключа i есть в словаре dict, то увеличиваем значение переменной result на i.
# 1.2) Если ключа i нет в словаре dict, то добавляем ключ i co значением 0.
# 2) Создаем пересенную missingNumber со значением (lenNums * (lenNums + 1)) // 2 - (суммой всех чисел из массива nums - result).
# 3) Вернуть массив с числами result и missingNumber.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

nums = [1, 2, 2, 4]

def findErrorNums(nums):
    dict = {}
    result = 0
    lenNums = len(nums)

    for i in nums:
        if i in dict:
            # Увеличь result на i !!!
            result += i  # i = 2, # Увеличь result на i !!!
        else:
            dict[i] = 0
    # dict = {1: 0, 2: 0, 4: 0}
    # (4     *  (4  + 1)       // 2 - (9         -    2)  = 3
    missingNumber = (lenNums * (lenNums + 1)) // 2 - (sum(nums) - result)
    #   [2,         3]
    return [result, missingNumber]

findErrorNums(nums)

# assert findErrorNums(nums=[1, 2, 2, 4]) == [2, 3]
# assert findErrorNums(nums=[1, 1]) == [1, 2]
# assert findErrorNums(nums=[2, 2]) == [2, 1]  # этот тест ломает последний код !!!
# Доп юнитесты для проверки некоторых условий:
# assert findErrorNums(nums=[3, 2, 3, 4, 5]) == [3, 1]  # Случай с отсутствующим числом в конце
# assert findErrorNums(nums=[1, 2, 3, 4, 4, 6]) == [4, 5]  # Случай с большим диапазоном

### Старое рабочие решение через хэш таблицу !!! ###

# Полное объяснение решение задачи:
# 0) Создаем пересенную result равной 0, пустой словарь dict и переменную
# actualSum ранваное длины массива nums умноженое (длины массива nums +1) деленае на 2.
# 1) Проходимся циклом по массиву nums,
# 1.1) Если ключа i нету в словаре dict, то добавляем ключ i co значением 0.
# 1.2) Если ключа i есть в словаре dict, то увеличиваем значение переменной result на i.
# 2) Вернуть массив числе переменная result и переменная y- сумма массива nums + переменная result.
#
# Сложность:
# 1) Время O(n)
# 2) Память O(n)
#
# nums = [1, 2, 2, 4]
#
# def findErrorNums(nums):
#     result = 0
#     dict = {}
#     actualSum = len(nums) * (len(nums) + 1) // 2  # 10 - это фактическая сумма
#
#     for i in nums:
#         if i not in dict:
#             dict[i] = 0
#         else:
#             result += i # i = 2 , это число из массива nums !!!
#     # {1: 0, 2: 0, 4: 0}
#     #          2  ,        10 -     9     +   2
#     return [result, actualSum - sum(nums) + result]
#
# findErrorNums(nums)

### Не проходят все тесты 7 / 49
# Полное объяснение решение задачи:
#
# Сложность:
# 1) Время O(n)
# 2) Память O(n)
#
# nums = [1, 2, 2, 4]
#
# def findErrorNums(nums):
#     dict = {}
#
#     for i in nums:
#         if i in dict:
#             dict[i] += 1
#         else:
#             dict[i] = 1
#     # {1: 1, 2: 2, 4: 1}
#     maxKey = max(dict, key=dict.get) # 2
#             # 2      # 2 + 1
#     return [maxKey, maxKey + 1]
#
# findErrorNums(nums)
