### Условие задачи:
# Вы ведете счет бейсбольного матча по странным правилам. В начале игры вы начинаете с пустой записью.
# Вам предоставляется список строк operations, где operations[i]указывается операция,
# которую необходимо применить к записи, и является одной из следующих:ith
# Целое число x.
# Запишите новый счет x.
# '+'.
# Запишите новый результат, который представляет собой сумму двух предыдущих баллов.
# 'D'.
# Запишите новый результат, в два раза превышающий предыдущий.
# 'C'.
# Аннулировать предыдущий результат, удалив его из записи.
# Возвращает сумму всех оценок в записи после применения всех операций .
# Тестовые случаи генерируются таким образом, чтобы ответ и все промежуточные вычисления умещались
# в 32-битное целое число и чтобы все операции были допустимы.

# Example 1:
# Input: ops = ["5","2","C","D","+"]
# Output: 30
# "5" — добавьте 5 к записи, запись теперь будет [5].
# «2» — добавить к записи 2, запись теперь [5, 2].
# «C» — аннулировать и удалить предыдущий балл, теперь запись [5]. .pop()
# «D» — прибавьте к записи 2*5=10, запись теперь будет [5, 10]. D=stack[-1]*2 stack.append(D)
# «+» — добавить к записи 5+10=15, запись теперь [5, 10, 15]. + = stack[-1] + 5 stack.append(+)
# Общая сумма равна 5 + 10 + 15 = 30.

# Example 2:
# Input: ops = ["5","-2","4","C","D","9","+","+"]
# Output: 27

# Example 3:
# Input: ops = ["1","C"]
# Output: 0

### Краткое условие:
# Надо пройтись по массиву и посчитать очки с условием, что буквы дают очки.

# Алгоритм решение задачи:
# 0) Создать пустой массив stack
# 1) Пройтись циклом по массиву ops
# 1.1) Если попадается цифра добавляем (отрицателяная или положительная) ее в массив stack
# 1.2) Если попадается буква «C», то убираем последний элемент в массив stack
# 1.3) Если попадается буква «D», то берем последний элемент массива stack и умножаем его на 2,
# полученое число добавляем в массив stack
# 1.4) Если попадается символ «+», то берем последний элемент массива stack,
# и предпоследний элемент stack затем складываем их и результат записываем в массив stack
# 2) вернуть return сложить все элементы массива stack и вывести число

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

ops = ["5", "-2", "4", "C", "D", "9", "+", "+"]

def calPoints(ops):
    stack = []

    for i in ops:
        if i.lstrip("-").isdigit(): # lstrip + isdigit это для того чтобы проходили отрицательные числа и положительные числа
            stack.append(int(i))
        elif i == "C":
            stack.pop()
        elif i == "D":
            stack.append(stack[-1] * 2)
        elif i == "+":
            stack.append(stack[-1] + stack[-2])
    # [5, -2, -4, 9, 5, 14]
    return sum(stack) # 27

calPoints(ops)

assert calPoints(ops=["5", "2", "C", "D", "+"]) == 30
assert calPoints(ops=["5", "-2", "4", "C", "D", "9", "+", "+"]) == 27
assert calPoints(ops=["1", "C"]) == 0