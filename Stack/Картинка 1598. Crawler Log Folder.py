### Условие задачи:
# Файловая система Leetcode ведет журнал каждый раз, когда какой-либо пользователь выполняет операцию изменения папки.
# Операции описаны ниже:
# "../": переход в родительскую папку текущей папки. (Если вы уже находитесь в основной папке, оставайтесь в той же папке).
# "./": оставаться в той же папке.
# "x/": перейти к указанной дочерней папке x(эта папка гарантированно будет существовать всегда).
# Вам предоставляется список строк, logs в которых logs[i] указана операция, выполняемая пользователем на шаге.ith
# Файловая система запускается в основной папке, затем logs выполняются операции в ней.
# Возвращает минимальное количество операций, необходимое для возврата в основную папку после операций изменения папки.

# Example 1:
# Input: logs = ["d1/","d2/","../","d21/","./"]
# Output: 2

# Example 2:
# Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
# Output: 3

# Example 3:
# Input: logs = ["d1/","../","../","../"]
# Output: 0

### Краткое условие:
# Удалить из массива элементы: "../" и "./" и вернуть длину массива.

# Алгоритм решение задачи:
# 0) Создать пустой массив stack
# 1) бежать по всем логам
# 1.1) если встречаем (../) --> stack.pop()
# 1.2) если встречаем (./) --> не чего не делаем
# 1.3) если встречаем папку (ххх/) --> stack.append()
# 2) return колличество элементов в stack.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

logs = ["./", "../", "./"]

def minOperations(logs):
    stack = []

    for i in logs:
        if len(stack) > 0 and i == '../':
            stack.pop()
        elif i != './':
            stack.append(i)
            if i == '../':
                stack.pop()
    # stack = []
    return len(stack)  # 0

minOperations(logs)

assert minOperations(logs=["d1/", "d2/", "../", "d21/", "./"]) == 2
assert minOperations(logs=["d1/", "d2/", "./", "d3/", "../", "d31/"]) == 3
assert minOperations(logs=["d1/", "../", "../", "../"]) == 0
assert minOperations(logs=["./", "../", "./"]) == 0