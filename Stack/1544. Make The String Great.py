### Условие задачи:
# Дана строка s строчных и прописных английских букв.
# Хорошая строка — это строка, в которой нет двух соседних символов s[i] и s[i + 1] где:
# 0 <= i <= s.length - 2
# s[i] — это строчная буква и s[i + 1] та же буква, но в верхнем регистре или наоборот.
# Чтобы сделать строку хорошей, вы можете выбрать два соседних символа, которые делают строку плохой, и удалить их.
# Вы можете продолжать делать это, пока струна не станет хорошей.
# Верните строку после того, как исправите ее. Ответ гарантированно будет уникальным при заданных ограничениях.
# Обратите внимание, что пустая строка тоже подойдет.

# Example 1:
# Input: s = "leEeetcode"
# Output: "leetcode"

# Example 2:
# Input: s = "abBAcC"
# Output: ""

# Example 3:
# Input: s = "s"
# Output: "s"

### Краткое условие:
# Пройтись по строке, если заглавная буква совподает с малеькой буквой, удалить заглавную букву и маленькую букву из строки.

# Алгоритм решение задачи:
# 0) Создать пустой массив stack.
# 1) Пройтись по стороке:
# 1.1) если буква в стеке совпадает с заглавная буквой в строке, то удалить .pop() букву из стека
# 1.2) если буква в стеке НЕ совпадает с буквой в строке, то добовляем .append() букву в стек
# 2) вернуть return строку из элементов массива stack.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

s = "leEeetcode"

def makeGood(s):
    stack = []

    for i in range(len(s)):  # range(0, 10)
        if len(stack) > 0 and stack[-1] == s[i].swapcase():  # swapcase - проверка заглавной буквы
            # ['l', 'e']
            stack.pop()
            # ['l']
        else:
            stack.append(s[i])
    # ['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']
    return ''.join(stack) # leetcode

makeGood(s)

assert makeGood(s="leEeetcode") == "leetcode"
assert makeGood(s="abBAcC") == ""
assert makeGood(s="s") == "s"