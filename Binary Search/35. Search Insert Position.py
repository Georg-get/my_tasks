### Условие задачи:
# Учитывая отсортированный массив различных целых чисел и целевое значение, верните индекс, если цель найдена.
# Если нет, верните индекс там, где он был бы, если бы он был вставлен по порядку.
# Вы должны написать алгоритм со O(log n) сложностью выполнения.

# Example 1:
# Input: nums = [1,3,5,6], target = 5
# Output: 2

# Example 2:
# Input: nums = [1,3,5,6], target = 2
# Output: 1

# Example 3:
# Input: nums = [1,3,5,6], target = 7
# Output: 4

### Краткое условие:
# Необходимо вернуть индекс числа target, если целевое значение найдено.
# Если нет, вернуть индекс, по которому оно должно быть вставлено, сохраняя порядок.

# Краткое объяснение решение задачи:
# 1. Устанавливаем левый указатель на первый элемент массива и правый указатель на последний элемент массива
# 2. Проходимся циклом пока левый и правый указатель не пересекутся,
# вычисляет средний индекс mid.
# 3. Сравниваем:
#    - Если элемент по индексу mid равен target, возвращает индекс mid.
#    - Если элемент больше target, сужает поиск до левой половины.
#    - Если элемент меньше target, сужает поиск до правой половины.
# 4. Если элемент не найден, возвращает индекс left, который указывает на позицию для вставки target.

# Полное объяснение решение задачи:
# 0) Написать функцию бинарный поиска.
# 1) Если бинарном поиском удалось найти число target, в массиве nums, то верни номер индекса в массиве nums.
# 1.1) Если числа target, нету в массиве nums, то добавь число target, в массиве nums,
# 1.1.1) отсортируй массив nums по возврастанию элементов .
# 1.1.2) Вызвать функцию бинарный поиска.

# Сложность:
# 1) времени O(n log n)
# 2) памяти O(1)

nums = [1, 3, 5, 6]
target = 2

def searchInsert(nums, target):
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid

        elif nums[mid] > target:
            right = mid - 1

        else:
            left = mid + 1

    return left

searchInsert(nums, target)

assert searchInsert(nums=[1, 3, 5, 6], target=5) == 2
assert searchInsert(nums=[1, 3, 5, 6], target=2) == 1
assert searchInsert(nums=[1, 3, 5, 6], target=7) == 4
# Доп юнитесты для проверки некоторых условий:
assert searchInsert([], 5) == 0 # Тест на вставку в пустой массив
assert searchInsert([1, 3, 5, 6], 0) == 0 # Тест на вставку элемента, который меньше всех в массиве
assert searchInsert([1, 3, 5, 6], 7) == 4 # Тест на вставку элемента, который больше всех в массиве
assert searchInsert([1, 3, 5, 6], 5) == 2 # Тест на вставку элемента между существующими
assert searchInsert([1, 3, 5, 6], 4) == 2 # Тест на вставку элемента между меньшим и большим
assert searchInsert([1, 3, 5, 6], 6) == 3 # Тест на вставку элемента равного большему