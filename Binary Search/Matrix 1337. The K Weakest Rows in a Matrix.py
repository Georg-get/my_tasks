### Условие задачи:
# Вам дана m x n двоичная матрица mat из 1's (представляющих солдат) и 0's (представляющих гражданских лиц).
# Солдаты располагаются напротив мирных жителей. То есть все 1буквы появятся слева от всех 0 в каждой строке.
# Строка i слабее строки, j если верно одно из следующих условий:
# Число солдат в ряду i меньше количества солдат в ряду j.
# В обоих рядах одинаковое количество солдат и i < j.
# Возвращает индексы самых слабых строк в матрице, упорядоченные от самого слабого к самому сильному.k

# Example 1:
# Input: mat =
# [[1,1,0,0,0],
#  [1,1,1,1,0],
#  [1,0,0,0,0],
#  [1,1,0,0,0],
#  [1,1,1,1,1]],
# k = 3
# Output: [2,0,3]
# Explanation:
# The number of soldiers in each row is:
# - Row 0: 2
# - Row 1: 4
# - Row 2: 1
# - Row 3: 2
# - Row 4: 5
# The rows ordered from weakest to strongest are [2,0,3,1,4].


# Example 2:
# Input: mat =
# [[1,0,0,0],
#  [1,1,1,1],
#  [1,0,0,0],
#  [1,0,0,0]],
# k = 2
# Output: [0,2]

### Краткое условие:
# Надо сложить все единицы в массивах и убрать все массивы которые дальше числа k.
# Вывести номера этих массивов.

# Алгоритм решение задачи:
# 0) Создаем функцию бинарного поиска которая будет считать единицы в массие и возращать число единиц.
# 1) Создаем пустые массивы list и result.
# 2) Проходимся циклом по матрице mat, добавляем в массив list кортедж состоящий из числа единиц которые посчитала функция бинарного поиска и индекса массива вкутри матрицы mat.
# 3) Сортируем массив list.
# 4) Проходимся циклом по диапазону от 0 до k, добавляем второе число в кортедже в массив result.
# 5) Вернуть массив result.

# Сложность:
# 1) памяти O(m)
# 2) времени O(log n)

mat = [[1, 1, 0, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 0, 0, 0, 0],
       [1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1]]
k = 3

def kWeakestRows(mat, k):
    def binarySearch(num):
        left = 0
        right = len(num) - 1
        count = 0

        while left <= right:
            mid = (right + left) // 2

            if num[mid] == 0:
                right = mid - 1
            else:
                count += (mid - (left - 1))
                left = mid + 1

        return count

    list = []
    result = []
    for index, vect in enumerate(mat):
        list.append((binarySearch(vect), index))
    # [(2, 0), (4, 1), (1, 2), (2, 3), (5, 4)]
    list.sort()  # [(1, 2), (2, 0), (2, 3), (4, 1), (5, 4)]

    for i in range(k):
        result.append(list[i][1])

    return result  # [2, 0, 3]

kWeakestRows(mat, k)