### Условие задачи:
# Учитывая массив целых чисел nums, половина целых чисел в нем nums нечетные, а другая половина — четные.
# Отсортируйте массив так, чтобы каждый раз, когда nums[i]он нечетный, i был нечетным, а всякий раз,
# когда nums[i] он был четным, i он был четным.
# Возвращает любой массив ответов, удовлетворяющий этому условию.

# Example 1:
# Input: nums = [4,2,5,7]
# Output: [4,5,2,7]
# Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.

# Example 2:
# Input: nums = [2,3]
# Output: [2,3]

### Краткое условие:
# Надо поменять местами числа в массиве nums, кроме первого числа и последнего !

# Алгоритм решение задачи:
# 0) Создаем переменные left со значением 0 и right со значением длины массива nums-1.
# 1) Проходимся циклом ваилд пока left не станет меньше чем длина массива nums и пока right не станет больше чем длина массива nums,
# 1.1) Если число где стаит левый указатель четное, то увеличь переменную left на 2.
# 1.2) Если число где стаит правый указатель НЕ четное, то уменьши переменную right на 2.
# 1.3) Иначе, переренеси четное число в лево, не четное число в право, и увеличь переменную left на 2 и уменьши переменную right на 2.
# 2) Верни массив nums.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

nums = [4, 2, 5, 7]

def sortArrayByParityII(nums):
    left = 0
    right = len(nums) - 1

    while left < len(nums) and right > 0:

        if nums[left] % 2 == 0:
            left += 2

        elif nums[right] % 2 != 0:
            right -= 2

        else:
            nums[left], nums[right] = nums[right], nums[left]
            left += 2
            right -= 2

    return nums  # [4, 5, 2, 7]

sortArrayByParityII(nums)

assert sortArrayByParityII(nums=[4, 2, 5, 7]) == [4, 5, 2, 7]
assert sortArrayByParityII(nums=[2, 3]) == [2, 3]