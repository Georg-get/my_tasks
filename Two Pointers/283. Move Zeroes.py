### Условие задачи:
# Учитывая целочисленный массив nums, переместите все 0 элементы в конец, сохраняя относительный порядок ненулевых элементов.
# Обратите внимание , что вы должны сделать это на месте, не копируя массив.

# Example 1:
# Input: nums = [0,1,0,3,12]
# Output: [1,3,12,0,0]

# Example 2:
# Input: nums = [0]
# Output: [0]

### Краткое условие:
# Надо в массиве nums перенести нули в правую сторону и вернуть массив nums.

# Алгоритм решение задачи:
# 0) Создаем переменные: left со значнием 0 и right со значнием длины массива nums-1.
# 1) Проходимся циклома ваилд пока left не станет меньше right,
# 1.1) Если число где стаит левый указатель равно 0, то удали это число из массива nums,
# и добавь 0 в конец массива nums и уменьши значение переменной right на 1.
# 1.2) Если число где стаит правый указатель равно 0, то уменьши значение переменной right на 1.
# 1.3) Иначе, то увеличь значением переменной left на 1.
# 2) Верни массив nums.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

nums = [0, 1, 0, 3, 12]

def moveZeroes(nums):
    left = 0
    right = len(nums) - 1

    while left < right:  # пока левый и правый указатель не пересекутся
        if nums[left] == 0:
            nums.pop(left)
            nums.append(0)
            right -= 1

        elif nums[right] == 0:
            right -= 1

        else:
            left += 1
    # [1, 3, 12, 0, 0]
    return nums

moveZeroes(nums)

assert moveZeroes(nums=[0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]
assert moveZeroes(nums=[0]) == [0]