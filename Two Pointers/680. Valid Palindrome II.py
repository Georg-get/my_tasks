### Условие задачи:
# Дана строка s, возвращает значение true , если она s может быть палиндромом после удаления из нее не более одного символа.

# Example 1:
# Input: s = "aba"
# Output: true

# Example 2:
# Input: s = "abca"
# Output: true
# Explanation: You could delete the character 'c'.

# Example 3:
# Input: s = "abc"
# Output: false

### Краткое условие:
# Надо вернуть True если строка s палиндром или после удаление одного символа строка s станет палиндромом, иначе false.

# Краткое объяснение решение задачи:
# 1. Устанавливаются указатели левый указатель в начало строки, а правый указатель в конец строки.
# 2. Проходимся циклом пока левый и правый указатель не персекутся.
#    - Если символы на этих позициях не равны, создаются две новые строки:
#    одна с удалённым символом слева (string1), другая — справа (string2).
#    - Проверяется, является ли одна из новых строк палиндромом (читается одинаково с обеих сторон).
#   Если одна из строк — палиндром, то возвращаем True, иначе — False.
# Если все символы совпадают, функция возвращает True в конце.

# Полное объяснение решение задачи:
# 0) Создаем левый и правый указатель.
# 1) Проходимся циклом ваилд пока левый указатель не дойдкт до правого или не станет больше него,
# 1.1) Если элементы где стаит левый и правый указатель разные,
# 1.1.1) То создаем строку string1 без буквый где стаит правый указатель,
# 1.1.2) То создаем строку string2 без буквый где стаит левый указатель,
# 1.1.3) Если string1 равна string1 строке на обород или string2 равна string2 строке на обород, верни True.
# 1.1.4) Иначе, верни False.
# 1.2) Иначе, двигаем левый и правый указатели.
# 2) Вернуть True.

# Сложность:
# 1) Время O(n^2)
# 2) Память O(n)

s = "abca"

def validPalindrome(s):
    left = 0
    right = len(s) - 1

    while left <= right:
        if s[left] != s[right]:
            string1 = s[:left] + s[left + 1:] # aca
            string2 = s[:right] + s[right + 1:] # aba

            if string1 == string1[::-1] or string2 == string2[::-1]:
                return True
            else:
                return False
        else:
            left += 1
            right -= 1

    return True

validPalindrome(s)

assert validPalindrome(s="aba") == True
assert validPalindrome(s="abca") == True
assert validPalindrome(s="abc") == False # ОН !!! # Тест без палиндрома
# Доп юнитесты для проверки некоторых условий:
assert validPalindrome(s="a") == True # Тест с одним символом
assert validPalindrome(s="aa") == True # Тест с двумя одинаковыми символами
assert validPalindrome(s="ab") == True # Тест с двумя разными символами
assert validPalindrome(s="") == True # Тест с пустой строкой
assert validPalindrome(s="racecar") == True # Тест с уже палиндромом

### Старое решение, через два указателя !!
# Полное объяснение решение задачи:
# 0) Избавляемся в строке s от: пробелов, знаков препинания и большие буквы переделать в маленькие буквы.
# 0.1) Создаем переменные: left со значением 0 и right со значением длины строки s-1.
# 1) Проходимся циклом ваилд пока left не станет меньше чем right,
# 1.1) Если буква на которой установлен левый указатель НЕ равна букве на которой установлен правый указатель,
# 1.1.1) Если букву на которой установлен левый указатель нельзя удалить и она не будет равна букве где установлен правый указатель, то верни false.
# 1.2) Если буква на которой установлен левый указатель равна букве на которой установлен правый указатель,
# 1.2.1) Увеличь значением переменной left на 1 и уменьши значением переменной right на 1.
# 2) Верни True

# Сложность:
# 1) Время O(n)
# 2) Память O(n)
#
# s = "abca"
#
# def validPalindrome(s):
#     def checkPalin(left, right):
#         # s[left] = c
#         # s[right] = c
#         while left < right:
#             if s[left] != s[right]:
#                 return False # Тут завершается третий юнитест !!!
#             left += 1
#             right -= 1
#
#         return True
#
#     left = 0
#     right = len(s) - 1
#
#     while left < right:
#         if s[left] != s[right]:
#                             # 2(с)    2(с)
#             if checkPalin(left + 1, right) or checkPalin(left, right - 1):
#                 return True # Тут завершается ВТОРОЙ юнитест !!!
#             else:  # без этого куска не проходит третий юнитест !!!
#                 return False # Тут завершается третий юнитест !!!
#
#         left += 1
#         right -= 1
#
#     return True # Тут завершается ПЕРВЫЙ юнитест !!!
#
# validPalindrome(s)