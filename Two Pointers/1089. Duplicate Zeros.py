### Условие задачи:
# Учитывая целочисленный массив фиксированной длины arr, продублируйте каждое вхождение нуля, сдвигая оставшиеся элементы вправо.
# Обратите внимание, что элементы, превышающие длину исходного массива, не записываются.
# Внесите вышеуказанные изменения во входной массив и ничего не возвращайте.

# Example 1:
# Input: arr =  [1,0,2,3,0,4,5,0]
# Output:       [1,0,0,2,3,0,0,4]
# Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]

# Example 2:
# Input: arr = [1,2,3]
# Output: [1,2,3]
# Explanation: After calling your function, the input array is modified to: [1,2,3]

### Краткое условие:
# Учитывая целочисленный массив фиксированной длины arr, продублируйте каждое вхождение нуля, сдвигая оставшиеся элементы вправо.

# Алгоритм решение задачи:
# 0) Создаем переменные: left со значнием 0 и right со значнием длины массива arr.
# 1) Проходимся циклома ваилд пока left не станет меньше right,
# 1.1) Если число на котором установлен левый указатель в массиве arr равно 0,
# 1.1.1) Добовляем после числа где установлен левый указатель 0 в массив arr.
# 1.1.2) Удаляю последний элемент в массиве arr.
# 1.1.3) Увеличь значением переменной left на 1.
# 1.2) Увеличь значением переменной left на 1.
# 2) Верин массив arr.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

arr = [1, 0, 2, 3, 0, 4, 5, 0]

def duplicateZeros(arr):
    left = 0
    right = len(arr)

    while left < right:

        if arr[left] == 0:
            arr.insert(left + 1, 0)
            arr.pop()
            left += 1

        left += 1

    return arr # [1, 0, 0, 2, 3, 0, 0, 4]

duplicateZeros(arr)

assert duplicateZeros(arr=[1, 0, 2, 3, 0, 4, 5, 0]) == [1, 0, 0, 2, 3, 0, 0, 4]
assert duplicateZeros(arr=[1, 2, 3]) == [1, 2, 3]