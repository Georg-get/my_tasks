### Условие задачи:
# Учитывая целочисленный массив nums, переместите все четные целые числа в начало массива, а затем все нечетные целые числа.
# Возвращает любой массив, удовлетворяющий этому условию.

# Example 1:
# Input: nums = [3,1,2,4]
# Output: [2,4,3,1]
# Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

# Example 2:
# Input: nums = [0]
# Output: [0]

### ТУТ ПРОБЛЕМЫ С ТЕСТОВЫМИ ДАННАМИ !!!! ####

### Краткое условие:
# Надо отсортированить массив nums, чтобы в лева были числа которые четные, а в права были не четные числа.

# Алгоритм решение задачи:
# 0) Создаем переменные left со значением 0 и right со значением длины массива nums-1.
# 1) Проходимся циклом ваилд пока left не станет меньше чем right,
# 1.1) Если число где находится левый указатель не четное и число где находится правый указатель четное,
# 1.1.1) То переренеси четное число в лево, не четное число в право.
# 1.2) Если число где находится левый указатель четное, то увеличь значением переменной left на 1.
# 1.3) Если число где находится правый указатель НЕ четное, то увеличь значением переменной right на 1.
# 2) Верни массив nums.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

nums = [3, 1, 2, 4]

def sortArrayByParity(nums):
    left = 0
    right = len(nums) - 1

    while left < right:

        if nums[left] % 2 != 0 and nums[right] % 2 == 0:
            nums[left], nums[right] = nums[right], nums[left]

        if nums[left] % 2 == 0:
            left += 1

        if nums[right] % 2 != 0:
            right -= 1

    return nums

sortArrayByParity(nums)

assert sortArrayByParity(nums=[3, 1, 2, 4]) == [4, 2, 1, 3]
assert sortArrayByParity(nums=[0]) == [0]