### Условие задачи:
# Вам дан целочисленный массив длины с нулевым индексом, представляющий позиции нескольких фортов. может быть,
# или где:forts n forts[i] -1 0 1 -1означает, что на позиции нет форта .ith
# 0указывает на то, что на позиции находится вражеский форт .ith
# 1указывает на то, что форт на позиции находится под вашим командованием.ith
# Теперь вы решили переместить свою армию из одного из ваших фортов i на пустую позицию j так, чтобы:
# 0 <= i, j <= n - 1
# Армия перемещается только через вражеские форты. Формально для всех k где min(i,j) < k < max(i,j),forts[k] == 0.
# Во время движения армии захватываются все попадающиеся на пути вражеские форты.
# Верните максимальное количество вражеских фортов, которые можно захватить.
# В случае, если переместить свою армию невозможно или у вас нет форта под вашим командованием, возвращайтесь 0.

# Example 1:
# Input: forts = [1,0,0,-1,0,0,0,0,1]
# Output: 4
# Explanation:
# - Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
# - Moving the army from position 8 to position 3 captures 4 enemy forts.
# Since 4 is the maximum number of enemy forts that can be captured, we return 4.

# Example 2:
# Input: forts = [0,0,1,-1]
# Output: 0
# Explanation: Since no enemy fort can be captured, 0 is returned.

### Добавить в список !

### Краткое условие:
# Необходимо определить максимальное количество вражеских фортов, которые можно захватить,
# перемещая армию из одного из ваших фортов (позиция i) в пустую позицию (позиция j),
# при этом армия может проходить только через вражеские форты.
# Если перемещение невозможно или у вас нет фортов под командованием, вернуть 0.

### Решение без алгоритма !!!

# Краткое объяснение решение задачи:
# 1. Инициализация: result для хранения максимального количества захваченных фортов и j как индекс последнего найденного форта.
# 2. Цикл по массиву forts:
#    - Если текущий элемент не равен 0 (это форт):
#      - Проверяется, является ли предыдущий дружественный форт (forts[j]) противоположным к текущему (-forts[i]).
#      - Если да, обновляется result как максимальное значение между текущим result и количеством фортов между j и i (то есть i - j - 1).
#    - Обновляется индекс j на текущий элемент.
# 3. Возврат результата: Функция возвращает максимальное количество захваченных вражеских фортов.

# Полное объяснение решение задачи:
# 0) Создаем две переменные result и j со значением 0.
# 1) Проходимся циклом по диапазону от 0 до длины массива forts,
# 1.1) Если это не первый элемент массива forts,
# 1.1.1) Если элемент j равен отрицательному элементку i, то увеличь result на максивальное число из result или i - j - 1.
# 1.2) j ранво i.
# 2) Верни result.

# Сложность:
# 1) Время O(n)
# 2) Память O(1)

### Сложная задача !!!

forts = [1, 0, 0, -1, 0, 0, 0, 0, 1]

def captureForts(forts):
    result = 0
    j = 0

    for i in range(len(forts)):
        if forts[i] != 0:
            # -1 -> 1 -> -1
            if forts[j] == -forts[i]:  #
                result = max(result, i - j - 1)

            j = i

    return result

captureForts(forts)

assert captureForts(forts=[1, 0, 0, -1, 0, 0, 0, 0, 1]) == 4
assert captureForts(forts=[0, 0, 1, -1]) == 0
# Доп юнитесты для проверки некоторых условий:
assert captureForts(forts=[0, -1]) == 0  # Тест с одним фортом
assert captureForts(forts=[0, 0, 0, 0]) == 0  # Тест с несколькими фортами и отсутствием врагов
assert captureForts(forts=[1, 0, 0, 0, -1]) == 3  # Тест с фортами в начале и конце
assert captureForts(forts=[1, 0, -1, 1]) == 1  # Тест с фортами по всей длине массива

### Решение через стек !!!

# Полное объяснение решение задачи:

# Сложность:
# 1) Время O(n)
# 2) Память O(1)

# forts = [1, 0, 0, -1, 0, 0, 0, 0, 1]
#
# def captureForts(forts):
#     result = 0
#     cnt = 0
#     stack = []
#
#     for i in forts:
#
#         if i == 1:
#             if len(stack) > 0:
#                 temp = stack.pop()
#
#                 if temp == -1:
#                     result = max(result, cnt)
#
#                 cnt = 0
#
#             stack = [i]
#
#         elif i == -1:
#
#             if len(stack) > 0:
#                 temp = stack.pop()
#                 if temp == 1:
#                     result = max(result, cnt)
#
#                 cnt = 0
#
#             stack = [i]
#         else:
#             if len(stack) > 0:
#                 cnt += 1
#
#     return result

# captureForts(forts)

### Старое решение через два указателя !!!

# Полное объяснение решение задачи:
# 0) Создаем переменные: левый и правый указатель, lMax и rMax со значением 0, и lChk и rChk со значением False, и пустой массив result.
# 1) Проходимся циклом ваил пока левый указатель не станет меньше или равен правому указателю,
# 1.1) Если число из массива где установлен левый указатель равно 1,
# 1.1.1) То создай перемнные: inLeft со значением left + 1 и inRight со значением right.
# 1.1.2) Проходимся циклом ваилд пока inLeft не станет меньше или равен inRight,
# 1.1.2.1) Если число из массива forts где установлен inLeft равно 0, то увеличь перемнную lMax на 1.
# 1.1.2.2) Иначе если число из массива forts где установлен inLeft равно -1, то сделай перемунню lChk = True и выйди из цикла.
# 1.1.2.3) Иначе, выйди из цикла.
# 1.1.3) Увеличиваем значение переменой inLeft на 1.
# 1.2) Если lChk равно True, то добавь в массив result переменную lMax, и сделай lChk равную False.
# 1.3) lMax равен 0.
# 1.4) Увеличиваем left на 1.
# 2) Проходимся циклом ваил пока правый указатель не станет больше или равен 0,
# 2.1) Если число из массива где установлен правый указатель равно 1,
# 2.1.1) То создай перемнную: inRight со значением right - 1 .
# 2.1.2) Проходимся циклом ваилд пока inRight не станет больше или равен 0,
# 2.1.2.1) Если число из массива forts где установлен inRight равно 0, то увеличь перемнную rMax на 1.
# 2.1.2.2) Иначе если число из массива forts где установлен inRight равно -1, то сделай перемунню rChk = True и выйди из цикла.
# 2.1.2.3) Иначе, выйди из цикла.
# 2.1.3) Уменьшаем значение переменой inRight на 1.
# 2.2) Если rChk равно True, то добавь в массив result переменную rMax, и сделай lChk равную False.
# 2.3) rMax равен 0.
# 2.4) Уменьшаем right на 1.
# 3) Если длина массива result больше 0, то верни максимальный элемент из массива result.
# 4) Иначе, верни 0.

# Сложность:
# 1) Время O(n)
# 2) Память O(n)

# forts = [1, 0, 0, -1, 0, 0, 0, 0, 1]
#
# def captureForts(forts):
#     left = 0
#     right = len(forts) - 1
#     lMax = 0
#     rMax = 0
#     lChk = False
#     rChk = False
#     result = []
#
#     while left <= right:
#         if forts[left] == 1:
#             inLeft = left + 1
#             inRight = right
#
#             while inLeft <= inRight:
#                 if forts[inLeft] == 0:
#                     lMax += 1
#                 elif forts[inLeft] == -1:
#                     lChk = True
#                     break
#                 else:
#                     break
#
#                 inLeft += 1
#
#         if lChk == True:
#             result.append(lMax)
#             lChk = False
#
#         lMax = 0
#         left += 1
#
#     while right >= 0:
#         if forts[right] == 1:
#             inRight = right - 1
#
#             while inRight >= 0:
#                 if forts[inRight] == 0:
#                     rMax += 1
#                 elif forts[inRight] == -1:
#                     rChk = True
#                     break
#                 else:
#                     break
#
#                 inRight -= 1
#
#         if rChk == True:
#             result.append(rMax)
#             rChk = False
#
#         rMax = 0
#         right -= 1
#
#     if len(result) > 0:
#         # [2, 4]
#         return max(result) # 4
#     else:
#         return 0
#
# captureForts(forts)
