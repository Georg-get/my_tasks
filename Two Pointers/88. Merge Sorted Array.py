### Условие задачи:
# Вам даны два целочисленных массива nums1и nums2, отсортированные в порядке неубывания , и два целых числа mи n, представляющие количество элементов в nums1и nums2соответственно.
# Объединить nums1 и nums2 в один массив, отсортированный в порядке неубывания.
# Окончательно отсортированный массив не должен возвращаться функцией, а должен храниться внутри массива nums1.
# Для этого он nums1 имеет длину m + n, где первые mэлементы обозначают элементы, которые следует объединить, а последние nэлементы имеют значение 0и их следует игнорировать. nums2имеет длину n.

# Example 1:
# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# Output: [1,2,2,3,5,6]
# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

# Example 2:
# Input: nums1 = [1], m = 1, nums2 = [], n = 0
# Output: [1]
# Explanation: The arrays we are merging are [1] and [].
# The result of the merge is [1].

# Example 3:
# Input: nums1 = [0], m = 0, nums2 = [1], n = 1
# Output: [1]
# Explanation: The arrays we are merging are [] and [1].
# The result of the merge is [1].
# Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.


### Краткое условие:
# Необходимо объединить оба массива nums1 и nums2 в один отсортированный массив (без 0), сохранив результат в nums1.
# При этом nums1 имеет длину m + n, где первые m элементов — это элементы для слияния,
# а оставшиеся n элементов равны 0 и должны быть проигнорированы.

# Краткое объяснение решение задачи:
# 1. Ставил левый указатель на конец массива nums1, а правый указатель на конец массива nums2.
# 2. Проходисся циклом пока левый и правый указатель не дойдут до первого элемента своего массива,
#      - Сравниваются последние элементы текущих подмассивов.
#      - Больший элемент помещается в конец nums1.
#      - Указатель соответствующего массива уменьшается.
# 3. Если остались элементы в nums2, которые небыли скопированы в массив nums1, то копинуем их в начало массива nums1.
# 4. Возврат результата: то возвращаем обновленный nums1, который теперь содержит все элементы в отсортированном порядке.

# Полное объяснение решение задачи:
# 0) Создаем переменные left со значением m и right со значением n.
# 1) Проходисся циклом пока левый и правый указатель не дойдут до первого элемента своего массива,
# 1.1) Если число где установлен левый указатель больше чем число где установлен правый указатель,
# 1.1.1) То поменяй местами последний число с чеслом где установлен левый указатель,
# 1.1.2) Уменьши левый указатель на 1.
# 1.2) Иначе,
# 1.2.1) Поменяй последние число из массива nums1 на число где установлен правый указатель из массива nums2.
# 1.2.2) Уменьши правый указатель на 1.
# 2) Проходимся циклом ваилд пока правый указатель не будет равен 0,
# 2.1) Меняем местами числа из массивов nums1 и nums2 где установлен right, и уменьшаем right на 1.
# 3) Вернуть массив nums1.

# Сложность:
# 1) Время O(m + n)
# 2) Память O(1)

nums1 = [1, 2, 3, 0, 0, 0]
m = 3
nums2 = [2, 5, 6]
n = 3

def merge(nums1, m, nums2, n):
    left = m
    right = n

    while left > 0 and right > 0:                           # [1, 2, 3, 0, 0, 6]
        if nums1[left - 1] > nums2[right - 1]:              # [1, 2, 3, 0, 5, 6]
            nums1[left + right - 1] = nums1[left - 1]       # [1, 2, 3, 3, 5, 6]
            left -= 1                                       # [1, 2, 2, 3, 5, 6]
        else:
            nums1[left + right - 1] = nums2[right - 1]
            right -= 1

    while right > 0:
        nums1[right - 1] = nums2[right - 1]
        right -= 1

    return nums1

merge(nums1, m, nums2, n)

assert merge(nums1=[1, 2, 3, 0, 0, 0], m=3, nums2=[2, 5, 6], n=3) == [1, 2, 2, 3, 5, 6]
assert merge(nums1=[1], m=1, nums2=[], n=0) == [1]
assert merge(nums1=[0], m=0, nums2=[1], n=1) == [1]  # от него !!!
# Доп юнитесты для проверки некоторых условий:
assert merge(nums1=[1, 3, 5, 0, 0], m=3, nums2=[2, 4], n=2) == [1, 2, 3, 4, 5]  # Тест с уже отсортированными массивами
assert merge(nums1=[1, 2, 2, 0, 0, 0], m=3, nums2=[2, 3, 5], n=3) == [1, 2, 2, 2, 3, 5]  # Тест с дублирующимися элементами:

### Старое рабочие решение, через два указателя !!! ###

# Полное объяснение решение задачи:
# 0) Создаем переменные left со значением m - 1 и right со значением n - 1, и endArrNums1 со значением m + n - 1.
# 1) Проходимся циклом ваилд пока right не дойдет до 0.
# 1.1) Если left больше или ранво 0 и число где установлен левый указатель больше чем число где установлен правый указатель,
# 1.1.1) То меняем то число где установлен endArrNums1 на число где левый указатель, уменьшаем левый указатель на 1.
# 1.2) Иначе, меняем то число где установлен endArrNums1 на число где правый указатель, уменьшаем правый указатель на 1.
# 1.3) Уменьшаем endArrNums1 на 1.
# 2) Вернуть массив nums1.

# Сложность:
# 1) Время O(n)
# 2) Память O(1)

# nums1 = [1, 2, 3, 0, 0, 0]
# m = 3
# nums2 = [2, 5, 6]
# n = 3
#
# def merge(nums1, m, nums2, n):
#     left = m - 1
#     right = n - 1
#     endArrNums1 = m + n - 1
#
#     while right >= 0:
#
#         if left >= 0 and nums1[left] > nums2[right]:    # [1, 2, 3, 0, 0, 6]
#             nums1[endArrNums1] = nums1[left]            # [1, 2, 3, 0, 5, 6]
#             left -= 1                                   # [1, 2, 3, 3, 5, 6]
#                                                         # [1, 2, 2, 3, 5, 6]
#         else:
#             nums1[endArrNums1] = nums2[right]
#             right -= 1
#
#         endArrNums1 -= 1
#
#     return nums1
#
# merge(nums1, m, nums2, n)